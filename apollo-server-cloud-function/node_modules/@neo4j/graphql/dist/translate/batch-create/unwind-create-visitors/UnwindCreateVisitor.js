"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnwindCreateVisitor = void 0;
const create_relationship_validation_string_1 = __importDefault(require("../../create-relationship-validation-string"));
const utils_1 = require("../../../utils/utils");
const cypher_builder_1 = __importDefault(require("@neo4j/cypher-builder"));
const map_to_db_property_1 = __importDefault(require("../../../utils/map-to-db-property"));
const create_auth_predicates_1 = require("../../create-auth-predicates");
const constants_1 = require("../../../constants");
const get_relationship_direction_1 = require("../../../utils/get-relationship-direction");
const create_authorization_after_predicate_1 = require("../../authorization/create-authorization-after-predicate");
const check_authentication_1 = require("../../authorization/check-authentication");
const compile_cypher_1 = require("../../../utils/compile-cypher");
class UnwindCreateVisitor {
    constructor(unwindVar, callbackBucket, context) {
        this.unwindVar = unwindVar;
        this.callbackBucket = callbackBucket;
        this.context = context;
        this.environment = {};
    }
    visitChildren(currentASTNode, unwindVar, parentVar) {
        if (currentASTNode.children) {
            const childrenRefs = currentASTNode.children.map((children) => {
                this.environment[children.id] = { unwindVar, parentVar };
                children.accept(this);
                return children.id;
            });
            return childrenRefs.map((childrenRef) => this.environment[childrenRef].clause);
        }
        return [];
    }
    visitCreate(create) {
        const labels = create.node.getLabels(this.context);
        const currentNode = new cypher_builder_1.default.Node({
            labels,
        });
        const nestedClauses = this.visitChildren(create, this.unwindVar, currentNode);
        const setProperties = create.nodeProperties.map((property) => fieldToSetParam(create.node, currentNode, property, this.unwindVar.property(property)));
        const autogeneratedProperties = getAutoGeneratedFields(create.node, currentNode);
        const createClause = new cypher_builder_1.default.Create(currentNode).set(...setProperties, ...autogeneratedProperties);
        const relationshipValidationClause = new cypher_builder_1.default.RawCypher((env) => {
            const validationStr = (0, create_relationship_validation_string_1.default)({
                node: create.node,
                context: this.context,
                varName: env.getReferenceId(currentNode),
            });
            const cypher = [];
            if (validationStr) {
                cypher.push(`WITH ${env.getReferenceId(currentNode)}`);
                cypher.push(validationStr);
            }
            return cypher.join("\n");
        });
        (0, check_authentication_1.checkAuthentication)({ context: this.context, node: create.node, targetOperations: ["CREATE"] });
        const authNodeClause = this.getAuthNodeClause(create.node, this.context, currentNode);
        let authorizationFieldsClause;
        const authorizationPredicateReturn = this.getAuthorizationFieldClause({
            astNode: create,
            nodeRef: currentNode,
            unwindVar: this.unwindVar,
        });
        if (authorizationPredicateReturn) {
            const { predicate, preComputedSubqueries } = authorizationPredicateReturn;
            if (predicate) {
                if (preComputedSubqueries && !preComputedSubqueries.empty) {
                    authorizationFieldsClause = cypher_builder_1.default.concat(new cypher_builder_1.default.With("*"), preComputedSubqueries, new cypher_builder_1.default.With("*").where(predicate));
                }
                authorizationFieldsClause = new cypher_builder_1.default.With("*").where(predicate);
            }
        }
        // TODO: Authorization - delete for 4.0.0
        const authFieldsClause = this.getAuthFieldClause(create, this.context, currentNode, this.unwindVar);
        const clause = cypher_builder_1.default.concat(...(0, utils_1.filterTruthy)([
            createClause,
            ...nestedClauses,
            authNodeClause,
            authorizationFieldsClause,
            authFieldsClause,
            relationshipValidationClause,
            new cypher_builder_1.default.Return(currentNode),
        ]));
        this.rootNode = currentNode;
        this.clause = new cypher_builder_1.default.Call(clause).innerWith(this.unwindVar);
    }
    visitNestedCreate(nestedCreate) {
        const parentVar = this.environment[nestedCreate.id].parentVar;
        const unwindVar = this.environment[nestedCreate.id].unwindVar;
        const { node, relationship, relationshipPropertyPath } = nestedCreate;
        const blockWith = new cypher_builder_1.default.With(parentVar, unwindVar);
        const createUnwindVar = new cypher_builder_1.default.Variable();
        const createUnwindClause = new cypher_builder_1.default.Unwind([
            unwindVar.property(relationshipPropertyPath).property("create"),
            createUnwindVar,
        ]);
        const labels = node.getLabels(this.context);
        const currentNode = new cypher_builder_1.default.Node({
            labels,
        });
        const nodeVar = new cypher_builder_1.default.Variable();
        const edgeVar = new cypher_builder_1.default.Variable();
        const withCreate = new cypher_builder_1.default.With([createUnwindVar.property("node"), nodeVar], [createUnwindVar.property("edge"), edgeVar], parentVar);
        const nestedClauses = this.visitChildren(nestedCreate, nodeVar, currentNode);
        const createClause = new cypher_builder_1.default.Create(currentNode);
        const relationField = relationship[0];
        const relationshipVar = new cypher_builder_1.default.Relationship({ type: relationField.type });
        const direction = (0, get_relationship_direction_1.getCypherRelationshipDirection)(relationField);
        const relationshipPattern = new cypher_builder_1.default.Pattern(parentVar)
            .withoutLabels()
            .related(relationshipVar)
            .withDirection(direction)
            .to(currentNode)
            .withoutLabels();
        const mergeClause = new cypher_builder_1.default.Merge(relationshipPattern);
        const setPropertiesNode = nestedCreate.nodeProperties.map((property) => fieldToSetParam(node, currentNode, property, nodeVar.property(property)));
        const autogeneratedProperties = getAutoGeneratedFields(node, currentNode);
        createClause.set(...setPropertiesNode, ...autogeneratedProperties);
        if (nestedCreate.edgeProperties && nestedCreate.edgeProperties.length && nestedCreate.edge) {
            const setPropertiesEdge = nestedCreate.edgeProperties.map((property) => {
                return fieldToSetParam(nestedCreate.edge, relationshipVar, property, edgeVar.property(property));
            });
            const autogeneratedEdgeProperties = getAutoGeneratedFields(nestedCreate.edge, relationshipVar);
            mergeClause.set(...setPropertiesEdge, ...autogeneratedEdgeProperties);
        }
        const subQueryStatements = [blockWith, createUnwindClause, withCreate, createClause, mergeClause];
        const relationshipValidationClause = new cypher_builder_1.default.RawCypher((env) => {
            const validationStr = (0, create_relationship_validation_string_1.default)({
                node,
                context: this.context,
                varName: env.getReferenceId(currentNode),
            });
            const cypher = [];
            if (validationStr) {
                cypher.push(`WITH ${env.getReferenceId(currentNode)}`);
                cypher.push(validationStr);
            }
            return cypher.join("\n");
        });
        (0, check_authentication_1.checkAuthentication)({ context: this.context, node: nestedCreate.node, targetOperations: ["CREATE"] });
        const authNodeClause = this.getAuthNodeClause(nestedCreate.node, this.context, currentNode);
        let authorizationFieldsClause;
        const authorizationPredicateReturn = this.getAuthorizationFieldClause({
            astNode: nestedCreate,
            nodeRef: currentNode,
            unwindVar: nodeVar,
        });
        if (authorizationPredicateReturn) {
            const { predicate, preComputedSubqueries } = authorizationPredicateReturn;
            if (predicate) {
                if (preComputedSubqueries && !preComputedSubqueries.empty) {
                    authorizationFieldsClause = cypher_builder_1.default.concat(new cypher_builder_1.default.With("*"), preComputedSubqueries, new cypher_builder_1.default.With("*").where(predicate));
                }
                authorizationFieldsClause = new cypher_builder_1.default.With("*").where(predicate);
            }
        }
        // TODO: Authorization - delete for 4.0.0
        const authFieldsClause = this.getAuthFieldClause(nestedCreate, this.context, currentNode, nodeVar);
        subQueryStatements.push(...nestedClauses);
        subQueryStatements.push(authNodeClause);
        subQueryStatements.push(authorizationFieldsClause);
        subQueryStatements.push(authFieldsClause);
        subQueryStatements.push(relationshipValidationClause);
        subQueryStatements.push(new cypher_builder_1.default.Return([cypher_builder_1.default.collect(new cypher_builder_1.default.Literal(null)), new cypher_builder_1.default.Variable()]));
        const subQuery = cypher_builder_1.default.concat(...subQueryStatements);
        const callClause = new cypher_builder_1.default.Call(subQuery);
        const outsideWith = new cypher_builder_1.default.With(parentVar, unwindVar);
        this.environment[nestedCreate.id].clause = cypher_builder_1.default.concat(outsideWith, callClause);
    }
    getAuthNodeClause(node, context, nodeRef) {
        const authorizationPredicateReturn = (0, create_authorization_after_predicate_1.createAuthorizationAfterPredicate)({
            context,
            nodes: [
                {
                    variable: nodeRef,
                    node,
                },
            ],
            operations: ["CREATE"],
        });
        if (authorizationPredicateReturn) {
            const { predicate, preComputedSubqueries } = authorizationPredicateReturn;
            if (predicate) {
                if (preComputedSubqueries && !preComputedSubqueries.empty) {
                    return cypher_builder_1.default.concat(new cypher_builder_1.default.With("*"), preComputedSubqueries, new cypher_builder_1.default.With("*").where(predicate));
                }
                return new cypher_builder_1.default.With("*").where(predicate);
            }
        }
        else if (node.auth) {
            // TODO: Authorization - delete for 4.0.0
            const authExpr = (0, create_auth_predicates_1.createAuthPredicates)({
                entity: node,
                operations: "CREATE",
                context,
                bind: { node, varName: nodeRef },
            });
            if (authExpr) {
                return cypher_builder_1.default.concat(new cypher_builder_1.default.With("*").where(cypher_builder_1.default.apoc.util.validatePredicate(cypher_builder_1.default.not(authExpr), constants_1.AUTH_FORBIDDEN_ERROR)));
            }
        }
    }
    // TODO: Authorization - delete for 4.0.0
    getAuthFieldClause(astNode, context, nodeRef, unwindVar) {
        const authFields = astNode.node.primitiveFields.filter((field) => field.auth);
        const usedAuthFields = astNode.nodeProperties
            .flatMap((property) => {
            return authFields.filter((authField) => authField.fieldName === property);
        })
            .filter((n) => n);
        if (usedAuthFields.length) {
            return new cypher_builder_1.default.RawCypher((env) => {
                const fieldsPredicates = usedAuthFields
                    .map((field) => {
                    const fieldAuthCypher = (0, create_auth_predicates_1.createAuthPredicates)({
                        entity: field,
                        operations: "CREATE",
                        context,
                        bind: {
                            node: astNode.node,
                            varName: nodeRef,
                        },
                    });
                    if (fieldAuthCypher) {
                        return cypher_builder_1.default.or(cypher_builder_1.default.isNull(unwindVar.property(field.fieldName)), fieldAuthCypher);
                    }
                })
                    .filter((predicate) => predicate !== undefined);
                if (fieldsPredicates.length) {
                    const predicate = cypher_builder_1.default.not(cypher_builder_1.default.and(...fieldsPredicates));
                    const fieldsAuth = (0, compile_cypher_1.compileCypher)(cypher_builder_1.default.concat(new cypher_builder_1.default.With("*").where(cypher_builder_1.default.apoc.util.validatePredicate(predicate, constants_1.AUTH_FORBIDDEN_ERROR))), env);
                    const fieldsPredicateParams = fieldsPredicates.reduce((prev, next) => {
                        return {
                            ...prev[1],
                            ...next[1],
                        };
                    }, {});
                    return [fieldsAuth, fieldsPredicateParams];
                }
            });
        }
    }
    getAuthorizationFieldClause({ astNode, nodeRef, unwindVar, }) {
        const authorizationPredicates = [];
        let authorizationSubquery = undefined;
        const usedAuthFields = astNode.nodeProperties
            .flatMap((property) => {
            return astNode.node.primitiveFields.filter((authField) => authField.fieldName === property);
        })
            .filter((n) => n);
        for (const field of usedAuthFields) {
            (0, check_authentication_1.checkAuthentication)({
                context: this.context,
                node: astNode.node,
                targetOperations: ["CREATE"],
                field: field.fieldName,
            });
            const authorizationPredicateReturn = (0, create_authorization_after_predicate_1.createAuthorizationAfterPredicate)({
                context: this.context,
                nodes: [
                    {
                        variable: nodeRef,
                        node: astNode.node,
                        fieldName: field.fieldName,
                    },
                ],
                operations: ["CREATE"],
                conditionForEvaluation: cypher_builder_1.default.isNotNull(unwindVar.property(field.fieldName)),
            });
            if (authorizationPredicateReturn) {
                const { predicate, preComputedSubqueries } = authorizationPredicateReturn;
                if (predicate) {
                    if (preComputedSubqueries && !preComputedSubqueries.empty) {
                        authorizationSubquery = cypher_builder_1.default.concat(authorizationSubquery, preComputedSubqueries);
                    }
                    authorizationPredicates.push(predicate);
                }
            }
        }
        return {
            predicate: cypher_builder_1.default.and(...authorizationPredicates),
            preComputedSubqueries: authorizationSubquery,
        };
    }
    /*
     * Returns the Cypher Reference of the root Nodes and the Cypher Clause generated
     */
    build() {
        return [this.rootNode, this.clause];
    }
}
exports.UnwindCreateVisitor = UnwindCreateVisitor;
function getAutoGeneratedFields(graphQLElement, cypherNodeRef) {
    const setParams = [];
    const timestampedFields = graphQLElement.temporalFields.filter((x) => ["DateTime", "Time"].includes(x.typeMeta.name) && x.timestamps?.includes("CREATE"));
    timestampedFields.forEach((field) => {
        // DateTime -> datetime(); Time -> time()
        const relatedCypherExpression = cypher_builder_1.default[field.typeMeta.name.toLowerCase()]();
        setParams.push([
            cypherNodeRef.property(field.dbPropertyName),
            relatedCypherExpression,
        ]);
    });
    const autogeneratedIdFields = graphQLElement.primitiveFields.filter((x) => x.autogenerate);
    autogeneratedIdFields.forEach((field) => {
        setParams.push([
            cypherNodeRef.property(field.dbPropertyName),
            cypher_builder_1.default.randomUUID(),
        ]);
    });
    return setParams;
}
function fieldToSetParam(graphQLElement, cypherNodeRef, key, value) {
    const pointField = graphQLElement.pointFields.find((x) => key === x.fieldName);
    const dbName = (0, map_to_db_property_1.default)(graphQLElement, key);
    if (pointField) {
        if (pointField.typeMeta.array) {
            const comprehensionVar = new cypher_builder_1.default.Variable();
            const mapPoint = cypher_builder_1.default.point(comprehensionVar);
            const expression = new cypher_builder_1.default.ListComprehension(comprehensionVar, value).map(mapPoint);
            return [cypherNodeRef.property(dbName), expression];
        }
        return [cypherNodeRef.property(dbName), cypher_builder_1.default.point(value)];
    }
    return [cypherNodeRef.property(dbName), value];
}
//# sourceMappingURL=UnwindCreateVisitor.js.map