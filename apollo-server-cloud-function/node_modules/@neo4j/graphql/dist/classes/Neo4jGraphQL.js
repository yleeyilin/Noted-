"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const merge_1 = require("@graphql-tools/merge");
const debug_1 = __importDefault(require("debug"));
const schema_1 = require("../schema");
const verify_database_1 = __importDefault(require("./utils/verify-database"));
const asserts_indexes_and_constraints_1 = __importDefault(require("./utils/asserts-indexes-and-constraints"));
const wrapper_1 = require("../schema/resolvers/wrapper");
const defaultField_1 = require("../schema/resolvers/field/defaultField");
const utils_1 = require("../utils/utils");
const constants_1 = require("../constants");
const Neo4jDatabaseInfo_1 = require("./Neo4jDatabaseInfo");
const Executor_1 = require("./Executor");
const generate_model_1 = require("../schema-model/generate-model");
const resolvers_composition_1 = require("@graphql-tools/resolvers-composition");
const schema_2 = require("@graphql-tools/schema");
const utils_2 = require("@graphql-tools/utils");
const validation_1 = require("../schema/validation");
const schema_validation_1 = require("../schema/validation/schema-validation");
const make_document_to_augment_1 = require("../schema/make-document-to-augment");
const Neo4jGraphQLAuthorization_1 = require("./authorization/Neo4jGraphQLAuthorization");
class Neo4jGraphQL {
    constructor(input) {
        const { config = {}, driver, plugins, features, ...schemaDefinition } = input;
        this.driver = driver;
        this.config = config;
        this.plugins = plugins;
        this.features = features;
        this.schemaDefinition = schemaDefinition;
        this.checkEnableDebug();
        if (this.features?.authorization) {
            const authorizationSettings = this.features?.authorization;
            this.authorization = new Neo4jGraphQLAuthorization_1.Neo4jGraphQLAuthorization(authorizationSettings);
        }
    }
    get nodes() {
        if (!this._nodes) {
            throw new Error("You must await `.getSchema()` before accessing `nodes`");
        }
        return this._nodes;
    }
    get relationships() {
        if (!this._relationships) {
            throw new Error("You must await `.getSchema()` before accessing `relationships`");
        }
        return this._relationships;
    }
    async getSchema() {
        return this.getExecutableSchema();
    }
    async getExecutableSchema() {
        if (!this.executableSchema) {
            this.executableSchema = this.generateExecutableSchema();
            await this.pluginsSetup();
        }
        return this.executableSchema;
    }
    async getSubgraphSchema() {
        console.warn("Apollo Federation support is currently experimental. There will be missing functionality, and breaking changes may occur in patch and minor releases. It is not recommended to use it in a production environment.");
        if (!this.subgraphSchema) {
            this.subgraphSchema = this.generateSubgraphSchema();
            await this.pluginsSetup();
        }
        return this.subgraphSchema;
    }
    async checkNeo4jCompat({ driver, driverConfig, sessionConfig, } = {}) {
        const neo4jDriver = driver || this.driver;
        if (!neo4jDriver) {
            throw new Error("neo4j-driver Driver missing");
        }
        if (!this.dbInfo) {
            this.dbInfo = await this.getNeo4jDatabaseInfo(neo4jDriver, sessionConfig || driverConfig || this.config?.driverConfig);
        }
        return (0, verify_database_1.default)({
            driver: neo4jDriver,
            sessionConfig: sessionConfig || driverConfig || this.config?.driverConfig,
            dbInfo: this.dbInfo,
        });
    }
    async assertIndexesAndConstraints({ driver, driverConfig, sessionConfig, options, } = {}) {
        if (!(this.executableSchema || this.subgraphSchema)) {
            throw new Error("You must await `.getSchema()` before `.assertIndexesAndConstraints()`");
        }
        await (this.executableSchema || this.subgraphSchema);
        const neo4jDriver = driver || this.driver;
        if (!neo4jDriver) {
            throw new Error("neo4j-driver Driver missing");
        }
        if (!this.dbInfo) {
            this.dbInfo = await this.getNeo4jDatabaseInfo(neo4jDriver, sessionConfig || driverConfig || this.config?.driverConfig);
        }
        await (0, asserts_indexes_and_constraints_1.default)({
            driver: neo4jDriver,
            sessionConfig: sessionConfig || driverConfig || this.config?.driverConfig,
            nodes: this.nodes,
            options: options,
            dbInfo: this.dbInfo,
        });
    }
    neo4jValidateGraphQLDocument() {
        try {
            const initialDocument = this.getDocument(this.schemaDefinition.typeDefs);
            (0, validation_1.validateDocument)({ document: initialDocument, features: this.features });
            const { document, typesExcludedFromGeneration } = (0, make_document_to_augment_1.makeDocumentToAugment)(initialDocument);
            const { jwt } = typesExcludedFromGeneration;
            const { typeDefs } = (0, schema_1.makeAugmentedSchema)(document, {
                features: this.features,
                enableRegex: false,
                validateResolvers: true,
                generateSubscriptions: true,
                userCustomResolvers: undefined,
            });
            (0, schema_validation_1.validateUserDefinition)({
                userDocument: document,
                augmentedDocument: typeDefs,
                jwt: jwt?.type,
            });
        }
        catch (error) {
            // TODO: include path here
            if (error instanceof Error) {
                const validationErrors = error.message.split("\n\n");
                return { isValid: false, validationErrors };
            }
            return { isValid: false, validationErrors: [] };
        }
        return { isValid: true, validationErrors: [] };
    }
    addDefaultFieldResolvers(schema) {
        (0, utils_2.forEachField)(schema, (field) => {
            if (!field.resolve) {
                field.resolve = defaultField_1.defaultFieldResolver;
            }
        });
        return schema;
    }
    checkEnableDebug() {
        if (this.config.enableDebug === true || this.config.enableDebug === false) {
            if (this.config.enableDebug) {
                debug_1.default.enable(constants_1.DEBUG_ALL);
            }
            else {
                debug_1.default.disable();
            }
        }
    }
    getDocument(typeDefs) {
        return (0, merge_1.mergeTypeDefs)(typeDefs);
    }
    async getNeo4jDatabaseInfo(driver, sessionConfig) {
        const executorConstructorParam = {
            executionContext: driver,
            sessionConfig,
        };
        return (0, Neo4jDatabaseInfo_1.getNeo4jDatabaseInfo)(new Executor_1.Executor(executorConstructorParam));
    }
    wrapResolvers(resolvers) {
        if (!this.schemaModel) {
            throw new Error("Schema Model is not defined");
        }
        const config = {
            ...this.config,
            callbacks: this.features?.populatedBy?.callbacks ?? this.config.callbacks,
        };
        const wrapResolverArgs = {
            driver: this.driver,
            config,
            nodes: this.nodes,
            relationships: this.relationships,
            schemaModel: this.schemaModel,
            plugins: this.plugins,
            authorization: this.authorization,
            jwtPayloadFieldsMap: this.jwtFieldsMap,
        };
        const resolversComposition = {
            "Query.*": [(0, wrapper_1.wrapResolver)(wrapResolverArgs)],
            "Mutation.*": [(0, wrapper_1.wrapResolver)(wrapResolverArgs)],
            "Subscription.*": [(0, wrapper_1.wrapSubscription)(wrapResolverArgs)],
        };
        // Merge generated and custom resolvers
        const mergedResolvers = (0, merge_1.mergeResolvers)([...(0, utils_1.asArray)(resolvers), ...(0, utils_1.asArray)(this.schemaDefinition.resolvers)]);
        return (0, resolvers_composition_1.composeResolvers)(mergedResolvers, resolversComposition);
    }
    composeSchema(schema) {
        // TODO: Keeping this in our back pocket - if we want to add native support for middleware to the library
        // if (this.middlewares) {
        //     schema = applyMiddleware(schema, ...this.middlewares);
        // }
        // Get resolvers from schema - this will include generated _entities and _service for Federation
        const resolvers = (0, utils_2.getResolversFromSchema)(schema);
        // Wrap the resolvers using resolvers composition
        const wrappedResolvers = this.wrapResolvers(resolvers);
        // Add the wrapped resolvers back to the schema, context will now be populated
        (0, schema_2.addResolversToSchema)({ schema, resolvers: wrappedResolvers, updateResolversInPlace: true });
        return this.addDefaultFieldResolvers(schema);
    }
    generateExecutableSchema() {
        return new Promise((resolve) => {
            const initialDocument = this.getDocument(this.schemaDefinition.typeDefs);
            const { validateTypeDefs, validateResolvers } = this.parseStartupValidationConfig();
            if (validateTypeDefs) {
                (0, validation_1.validateDocument)({ document: initialDocument, features: this.features });
            }
            const { document, typesExcludedFromGeneration } = (0, make_document_to_augment_1.makeDocumentToAugment)(initialDocument);
            const { jwt } = typesExcludedFromGeneration;
            if (jwt) {
                this.jwtFieldsMap = jwt.jwtFieldsMap;
            }
            if (!this.schemaModel) {
                this.schemaModel = (0, generate_model_1.generateModel)(document);
            }
            const { nodes, relationships, typeDefs, resolvers } = (0, schema_1.makeAugmentedSchema)(document, {
                features: this.features,
                enableRegex: this.config?.enableRegex,
                validateResolvers,
                generateSubscriptions: Boolean(this.plugins?.subscriptions),
                callbacks: this.features?.populatedBy?.callbacks ?? this.config.callbacks,
                userCustomResolvers: this.schemaDefinition.resolvers,
            });
            if (validateTypeDefs) {
                (0, schema_validation_1.validateUserDefinition)({
                    userDocument: document,
                    augmentedDocument: typeDefs,
                    jwt: jwt?.type,
                });
            }
            this._nodes = nodes;
            this._relationships = relationships;
            const schema = (0, schema_2.makeExecutableSchema)({
                ...this.schemaDefinition,
                typeDefs,
                resolvers,
            });
            resolve(this.composeSchema(schema));
        });
    }
    async generateSubgraphSchema() {
        // Import only when needed to avoid issues if GraphQL 15 being used
        const { Subgraph } = await Promise.resolve().then(() => __importStar(require("./Subgraph")));
        const initialDocument = this.getDocument(this.schemaDefinition.typeDefs);
        const subgraph = new Subgraph(this.schemaDefinition.typeDefs);
        const { directives, types } = subgraph.getValidationDefinitions();
        const { validateTypeDefs, validateResolvers } = this.parseStartupValidationConfig();
        if (validateTypeDefs) {
            (0, validation_1.validateDocument)({
                document: initialDocument,
                features: this.features,
                additionalDirectives: directives,
                additionalTypes: types,
            });
        }
        const { document, typesExcludedFromGeneration } = (0, make_document_to_augment_1.makeDocumentToAugment)(initialDocument);
        const { jwt } = typesExcludedFromGeneration;
        if (jwt) {
            this.jwtFieldsMap = jwt.jwtFieldsMap;
        }
        if (!this.schemaModel) {
            this.schemaModel = (0, generate_model_1.generateModel)(document);
        }
        const { nodes, relationships, typeDefs, resolvers } = (0, schema_1.makeAugmentedSchema)(document, {
            features: this.features,
            enableRegex: this.config?.enableRegex,
            validateResolvers,
            generateSubscriptions: Boolean(this.plugins?.subscriptions),
            callbacks: this.features?.populatedBy?.callbacks ?? this.config.callbacks,
            userCustomResolvers: this.schemaDefinition.resolvers,
            subgraph,
        });
        if (validateTypeDefs) {
            (0, schema_validation_1.validateUserDefinition)({
                userDocument: document,
                augmentedDocument: typeDefs,
                additionalDirectives: directives,
                additionalTypes: types,
                jwt: jwt?.type,
            });
        }
        this._nodes = nodes;
        this._relationships = relationships;
        // TODO: Move into makeAugmentedSchema, add resolvers alongside other resolvers
        const referenceResolvers = subgraph.getReferenceResolvers(this._nodes, this.schemaModel);
        const schema = subgraph.buildSchema({
            typeDefs,
            resolvers: (0, merge_1.mergeResolvers)([resolvers, referenceResolvers]),
        });
        return this.composeSchema(schema);
    }
    parseStartupValidationConfig() {
        let validateTypeDefs = true;
        let validateResolvers = true;
        if (this.config?.startupValidation === false) {
            return {
                validateTypeDefs: false,
                validateResolvers: false,
            };
        }
        // TODO - remove in 4.0.0 when skipValidateTypeDefs is removed
        if (this.config?.skipValidateTypeDefs === true)
            validateTypeDefs = false;
        if (typeof this.config?.startupValidation === "object") {
            if (this.config?.startupValidation.typeDefs === false)
                validateTypeDefs = false;
            if (this.config?.startupValidation.resolvers === false)
                validateResolvers = false;
        }
        return {
            validateTypeDefs,
            validateResolvers,
        };
    }
    pluginsSetup() {
        if (this.pluginsInit) {
            return this.pluginsInit;
        }
        const setup = async () => {
            const subscriptionsPlugin = this.plugins?.subscriptions;
            if (subscriptionsPlugin) {
                subscriptionsPlugin.events.setMaxListeners(0); // Removes warning regarding leak. >10 listeners are expected
                if (subscriptionsPlugin.init) {
                    await subscriptionsPlugin.init();
                }
            }
        };
        this.pluginsInit = setup();
        return this.pluginsInit;
    }
}
exports.default = Neo4jGraphQL;
//# sourceMappingURL=Neo4jGraphQL.js.map