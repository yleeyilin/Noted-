"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAggregationInputFields = void 0;
const graphql_compose_1 = require("graphql-compose");
const classes_1 = require("../../classes");
const constants_1 = require("../../constants");
const constants_2 = require("../constants");
function createAggregationInputFields(nodeOrRelFields, sourceName, rel, schemaComposer) {
    const fields = [...nodeOrRelFields.primitiveFields, ...nodeOrRelFields.temporalFields];
    const aggregationFields = fields.filter((field) => {
        return !field.typeMeta.array && constants_1.WHERE_AGGREGATION_TYPES.includes(field.typeMeta.name);
    });
    if (!aggregationFields.length) {
        return;
    }
    const aggregationInputName = `${sourceName}${(0, graphql_compose_1.upperFirst)(rel.fieldName)}${nodeOrRelFields instanceof classes_1.Node ? `Node` : `Edge`}AggregationWhereInput`;
    const aggregationInput = schemaComposer.createInputTC({
        name: aggregationInputName,
        fields: {
            AND: `[${aggregationInputName}!]`,
            OR: `[${aggregationInputName}!]`,
            NOT: aggregationInputName,
        },
    });
    for (const aggregationField of aggregationFields) {
        if (!aggregationField.filterableOptions.byAggregate) {
            continue;
        }
        switch (aggregationField.typeMeta.name) {
            case "ID":
                createIDAggregationInputFields(aggregationInput, aggregationField);
                break;
            case "String":
                createStringAggregationInputFields(aggregationInput, aggregationField);
                break;
            // Types that you can average
            // https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-avg
            // https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-avg-duration
            // String uses avg(size())
            case "Int":
            case "Float":
            case "BigInt":
            case "Duration":
                createAverageAggregationInputFields(aggregationInput, aggregationField);
                break;
            default:
                createComparisonAggregationInputFields(aggregationInput, aggregationField);
                break;
        }
    }
    return aggregationInput;
}
exports.createAggregationInputFields = createAggregationInputFields;
function createComparisonAggregationInputFields(aggregationInput, field) {
    aggregationInput.addFields(constants_1.AGGREGATION_COMPARISON_OPERATORS.reduce((res, operator) => ({
        ...res,
        [`${field.fieldName}_${operator}`]: {
            type: field.typeMeta.name,
            directives: [constants_2.DEPRECATE_INVALID_AGGREGATION_FILTERS],
        },
        [`${field.fieldName}_MIN_${operator}`]: field.typeMeta.name,
        [`${field.fieldName}_MAX_${operator}`]: field.typeMeta.name,
    }), {}));
}
function createAverageAggregationInputFields(aggregationInput, field) {
    aggregationInput.addFields(constants_1.AGGREGATION_COMPARISON_OPERATORS.reduce((res, operator) => {
        let averageType = "Float";
        if (field.typeMeta.name === "BigInt") {
            averageType = "BigInt";
        }
        if (field.typeMeta.name === "Duration") {
            averageType = "Duration";
        }
        return {
            ...res,
            [`${field.fieldName}_${operator}`]: {
                type: field.typeMeta.name,
                directives: [constants_2.DEPRECATE_INVALID_AGGREGATION_FILTERS],
            },
            [`${field.fieldName}_AVERAGE_${operator}`]: averageType,
            [`${field.fieldName}_MIN_${operator}`]: field.typeMeta.name,
            [`${field.fieldName}_MAX_${operator}`]: field.typeMeta.name,
            ...(field.typeMeta.name !== "Duration"
                ? { [`${field.fieldName}_SUM_${operator}`]: field.typeMeta.name }
                : {}),
        };
    }, {}));
    return;
}
function createStringAggregationInputFields(aggregationInput, field) {
    aggregationInput.addFields(constants_1.AGGREGATION_COMPARISON_OPERATORS.reduce((res, operator) => {
        return {
            ...res,
            [`${field.fieldName}_${operator}`]: {
                type: `${operator === "EQUAL" ? "String" : "Int"}`,
                directives: [constants_2.DEPRECATE_INVALID_AGGREGATION_FILTERS],
            },
            [`${field.fieldName}_AVERAGE_${operator}`]: {
                type: "Float",
                directives: [constants_2.DEPRECATE_IMPLICIT_LENGTH_AGGREGATION_FILTERS],
            },
            [`${field.fieldName}_LONGEST_${operator}`]: {
                type: "Int",
                directives: [constants_2.DEPRECATE_IMPLICIT_LENGTH_AGGREGATION_FILTERS],
            },
            [`${field.fieldName}_SHORTEST_${operator}`]: {
                type: "Int",
                directives: [constants_2.DEPRECATE_IMPLICIT_LENGTH_AGGREGATION_FILTERS],
            },
            [`${field.fieldName}_AVERAGE_LENGTH_${operator}`]: "Float",
            [`${field.fieldName}_LONGEST_LENGTH_${operator}`]: "Int",
            [`${field.fieldName}_SHORTEST_LENGTH_${operator}`]: "Int",
        };
    }, {}));
    return;
}
function createIDAggregationInputFields(aggregationInput, field) {
    aggregationInput.addFields({
        [`${field.fieldName}_EQUAL`]: {
            type: `ID`,
            directives: [constants_2.DEPRECATE_INVALID_AGGREGATION_FILTERS],
        },
    });
    return;
}
//# sourceMappingURL=create-aggregation-input-fields.js.map