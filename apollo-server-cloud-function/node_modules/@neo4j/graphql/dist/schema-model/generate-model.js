"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateModel = void 0;
const classes_1 = require("../classes");
const get_definition_nodes_1 = require("../schema/get-definition-nodes");
const get_field_type_meta_1 = __importDefault(require("../schema/get-field-type-meta"));
const utils_1 = require("../utils/utils");
const Neo4jGraphQLSchemaModel_1 = require("./Neo4jGraphQLSchemaModel");
const Attribute_1 = require("./attribute/Attribute");
const CompositeEntity_1 = require("./entity/CompositeEntity");
const ConcreteEntity_1 = require("./entity/ConcreteEntity");
const authorization_annotation_1 = require("./parser/authorization-annotation");
const cypher_annotation_1 = require("./parser/cypher-annotation");
const key_annotation_1 = require("./parser/key-annotation");
const utils_2 = require("./parser/utils");
const Relationship_1 = require("./relationship/Relationship");
const authentication_annotation_1 = require("./parser/authentication-annotation");
const Operation_1 = require("./Operation");
const Field_1 = require("./attribute/Field");
const subscriptions_authorization_annotation_1 = require("./parser/subscriptions-authorization-annotation");
function generateModel(document) {
    const definitionNodes = (0, get_definition_nodes_1.getDefinitionNodes)(document);
    const operations = definitionNodes.operations.reduce((acc, definition) => {
        acc[definition.name.value] = generateOperation(definition);
        return acc;
    }, {});
    // init interface to typeNames map
    const interfaceToImplementingTypeNamesMap = initInterfacesToTypeNamesMap(definitionNodes);
    // hydrate interface to typeNames map
    hydrateInterfacesToTypeNamesMap(definitionNodes, interfaceToImplementingTypeNamesMap);
    const concreteEntities = definitionNodes.objectTypes.map(generateConcreteEntity);
    const concreteEntitiesMap = concreteEntities.reduce((acc, entity) => {
        if (acc.has(entity.name)) {
            throw new classes_1.Neo4jGraphQLSchemaValidationError(`Duplicate node ${entity.name}`);
        }
        acc.set(entity.name, entity);
        return acc;
    }, new Map());
    const interfaceEntities = Array.from(interfaceToImplementingTypeNamesMap.entries()).map(([name, concreteEntities]) => {
        return generateCompositeEntity(name, concreteEntities, concreteEntitiesMap);
    });
    const unionEntities = definitionNodes.unionTypes.map((entity) => {
        return generateCompositeEntity(entity.name.value, entity.types?.map((t) => t.name.value) || [], concreteEntitiesMap);
    });
    const schemaDirectives = definitionNodes.schemaExtensions.reduce((directives, schemaExtension) => {
        if (schemaExtension.directives) {
            directives.push(...schemaExtension.directives);
        }
        return directives;
    }, []);
    const annotations = createSchemaModelAnnotations(schemaDirectives);
    const schema = new Neo4jGraphQLSchemaModel_1.Neo4jGraphQLSchemaModel({
        compositeEntities: [...unionEntities, ...interfaceEntities],
        concreteEntities,
        operations,
        annotations,
    });
    definitionNodes.objectTypes.map((def) => hydrateRelationships(def, schema, definitionNodes));
    return schema;
}
exports.generateModel = generateModel;
function initInterfacesToTypeNamesMap(definitionNodes) {
    return definitionNodes.interfaceTypes.reduce((acc, entity) => {
        const interfaceTypeName = entity.name.value;
        acc.set(interfaceTypeName, []);
        return acc;
    }, new Map());
}
function hydrateInterfacesToTypeNamesMap(definitionNodes, interfaceToImplementingTypeNamesMap) {
    return definitionNodes.objectTypes.forEach((el) => {
        if (!el.interfaces) {
            return;
        }
        const objectTypeName = el.name.value;
        el.interfaces?.forEach((i) => {
            const interfaceTypeName = i.name.value;
            const concreteEntities = interfaceToImplementingTypeNamesMap.get(interfaceTypeName);
            if (!concreteEntities) {
                throw new classes_1.Neo4jGraphQLSchemaValidationError(`Could not find composite entity with name ${interfaceTypeName}`);
            }
            interfaceToImplementingTypeNamesMap.set(interfaceTypeName, concreteEntities.concat(objectTypeName));
        });
    });
}
function generateCompositeEntity(entityDefinitionName, entityImplementingTypeNames, concreteEntities) {
    const compositeFields = entityImplementingTypeNames.map((type) => {
        const concreteEntity = concreteEntities.get(type);
        if (!concreteEntity) {
            throw new classes_1.Neo4jGraphQLSchemaValidationError(`Could not find concrete entity with name ${type}`);
        }
        return concreteEntity;
    });
    // TODO: fix for interfaces annotated with @relationshipFields - which will never have concrete entities
    // if (!compositeFields.length) {
    //     throw new Neo4jGraphQLSchemaValidationError(
    //         `Composite entity ${entityDefinitionName} has no concrete entities`
    //     );
    // }
    // TODO: add annotations
    return new CompositeEntity_1.CompositeEntity({
        name: entityDefinitionName,
        concreteEntities: compositeFields,
    });
}
function hydrateRelationships(definition, schema, definitionNodes) {
    const name = definition.name.value;
    const entity = schema.getEntity(name);
    if (!schema.isConcreteEntity(entity)) {
        throw new Error(`Cannot add relationship to non-concrete entity ${name}`);
    }
    const relationshipPropertyInterfaces = getRelationshipPropertiesInterfaces(definitionNodes);
    const relationshipFields = (definition.fields || []).map((fieldDefinition) => {
        // TODO: use same relationship for 2 different entities if possible
        return generateRelationshipField(fieldDefinition, schema, entity, relationshipPropertyInterfaces);
    });
    for (const relationship of (0, utils_1.filterTruthy)(relationshipFields)) {
        entity.addRelationship(relationship);
    }
}
function getRelationshipPropertiesInterfaces(definitionNodes) {
    return (definitionNodes.interfaceTypes
        // Uncomment this to enforce @relationshipProperties in 4.0
        // .filter((interfaceDef: InterfaceTypeDefinitionNode) => {
        //     const relDirective = findDirective(interfaceDef.directives || [], "relationshipProperties");
        //     return Boolean(relDirective);
        // })
        .reduce((acc, interfaceDef) => {
        acc.set(interfaceDef.name.value, interfaceDef);
        return acc;
    }, new Map()));
}
function generateRelationshipField(field, schema, source, propertyInterfaces) {
    const fieldTypeMeta = (0, get_field_type_meta_1.default)(field.type);
    const relationshipDirective = findDirective(field.directives || [], "relationship");
    if (!relationshipDirective)
        return undefined;
    const fieldName = field.name.value;
    const relatedEntityName = fieldTypeMeta.name;
    const relatedToEntity = schema.getEntity(relatedEntityName);
    if (!relatedToEntity)
        throw new Error(`Entity ${relatedEntityName} Not Found`);
    const { type, direction, properties } = (0, utils_2.parseArguments)(relationshipDirective);
    let attributes = [];
    if (properties && typeof properties === "string") {
        const propertyInterface = propertyInterfaces.get(properties);
        if (!propertyInterface)
            throw new Error(`There is no matching interface defined with @relationshipProperties for properties "${properties}"`);
        const fields = (propertyInterface.fields || []).map((field) => generateAttribute(field));
        attributes = (0, utils_1.filterTruthy)(fields);
    }
    return new Relationship_1.Relationship({
        name: fieldName,
        type: type,
        attributes,
        source,
        target: relatedToEntity,
        direction: direction,
    });
}
function generateConcreteEntity(definition) {
    const fields = (definition.fields || []).map((fieldDefinition) => generateAttribute(fieldDefinition));
    const directives = (definition.directives || []).reduce((acc, directive) => {
        acc.set(directive.name.value, (0, utils_2.parseArguments)(directive));
        return acc;
    }, new Map());
    const labels = getLabels(definition, directives.get("node") || {});
    // TODO: add annotations inherited from interface
    return new ConcreteEntity_1.ConcreteEntity({
        name: definition.name.value,
        labels,
        attributes: (0, utils_1.filterTruthy)(fields),
        annotations: createEntityAnnotations(definition.directives || []),
    });
}
function getLabels(definition, nodeDirectiveArguments) {
    // TODO: use when removing label & additionalLabels
    // const nodeExplicitLabels = nodeDirectiveArguments.labels as string[];
    // return nodeExplicitLabels ?? [definition.name.value];
    if (nodeDirectiveArguments.labels?.length) {
        return nodeDirectiveArguments.labels;
    }
    const nodeLabel = nodeDirectiveArguments.label;
    const additionalLabels = (nodeDirectiveArguments.additionalLabels || []);
    const label = nodeLabel || definition.name.value;
    return [label, ...additionalLabels];
}
function generateAttribute(field) {
    const typeMeta = (0, get_field_type_meta_1.default)(field.type); // TODO: without originalType
    const attributeType = isAttributeType(typeMeta.name) ? typeMeta.name : Attribute_1.AttributeType.ObjectType;
    const annotations = createFieldAnnotations(field.directives || []);
    return new Attribute_1.Attribute({
        name: field.name.value,
        annotations,
        type: attributeType,
        isArray: Boolean(typeMeta.array),
    });
}
function generateField(field) {
    const annotations = createFieldAnnotations(field.directives || []);
    return new Field_1.Field({
        name: field.name.value,
        annotations,
    });
}
function isAttributeType(typeName) {
    return Object.values(Attribute_1.AttributeType).includes(typeName);
}
function findDirective(directives, name) {
    return directives.find((d) => {
        return d.name.value === name;
    });
}
function createFieldAnnotations(directives) {
    return (0, utils_1.filterTruthy)(directives.map((directive) => {
        switch (directive.name.value) {
            case "cypher":
                return (0, cypher_annotation_1.parseCypherAnnotation)(directive);
            case "authorization":
                return (0, authorization_annotation_1.parseAuthorizationAnnotation)(directive);
            case "authentication":
                return (0, authentication_annotation_1.parseAuthenticationAnnotation)(directive);
            case "subscriptionsAuthorization":
                return (0, subscriptions_authorization_annotation_1.parseSubscriptionsAuthorizationAnnotation)(directive);
            default:
                return undefined;
        }
    }));
}
function createEntityAnnotations(directives) {
    const entityAnnotations = [];
    // We only ever want to create one annotation even when an entity contains several key directives
    const keyDirectives = directives.filter((directive) => directive.name.value === "key");
    if (keyDirectives) {
        entityAnnotations.push((0, key_annotation_1.parseKeyAnnotation)(keyDirectives));
    }
    const annotations = (0, utils_1.filterTruthy)(directives.map((directive) => {
        switch (directive.name.value) {
            case "authorization":
                return (0, authorization_annotation_1.parseAuthorizationAnnotation)(directive);
            case "authentication":
                return (0, authentication_annotation_1.parseAuthenticationAnnotation)(directive);
            case "subscriptionsAuthorization":
                return (0, subscriptions_authorization_annotation_1.parseSubscriptionsAuthorizationAnnotation)(directive);
            default:
                return undefined;
        }
    }));
    return entityAnnotations.concat(annotations);
}
function createSchemaModelAnnotations(directives) {
    const schemaModelAnnotations = [];
    const annotations = (0, utils_1.filterTruthy)(directives.map((directive) => {
        switch (directive.name.value) {
            case "authentication":
                return (0, authentication_annotation_1.parseAuthenticationAnnotation)(directive);
            default:
                return undefined;
        }
    }));
    return schemaModelAnnotations.concat(annotations);
}
function generateOperation(definition) {
    const fields = (definition.fields || []).map((fieldDefinition) => generateField(fieldDefinition));
    return new Operation_1.Operation({
        name: definition.name.value,
        fields: (0, utils_1.filterTruthy)(fields),
        annotations: createEntityAnnotations(definition.directives || []),
    });
}
//# sourceMappingURL=generate-model.js.map